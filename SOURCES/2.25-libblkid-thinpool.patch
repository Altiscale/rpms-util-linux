diff -up util-linux-2.23.2/fdisks/fdisk.c.kzak util-linux-2.23.2/fdisks/fdisk.c
--- util-linux-2.23.2/fdisks/fdisk.c.kzak	2013-07-30 10:39:26.195738131 +0200
+++ util-linux-2.23.2/fdisks/fdisk.c	2015-07-03 10:30:50.378965526 +0200
@@ -34,6 +34,7 @@
 #include "canonicalize.h"
 #include "strutils.h"
 #include "closestream.h"
+#include "sysfs.h"
 
 #include "fdisksunlabel.h"
 #include "fdisksgilabel.h"
diff -up util-linux-2.23.2/include/sysfs.h.kzak util-linux-2.23.2/include/sysfs.h
--- util-linux-2.23.2/include/sysfs.h.kzak	2013-06-13 09:46:10.400650451 +0200
+++ util-linux-2.23.2/include/sysfs.h	2015-07-03 10:30:50.378965526 +0200
@@ -73,6 +73,8 @@ extern int sysfs_is_partition_dirent(DIR
 extern int sysfs_devno_to_wholedisk(dev_t dev, char *diskname,
             size_t len, dev_t *diskdevno);
 
+extern int sysfs_devno_is_lvm_private(dev_t devno);
+
 extern int sysfs_scsi_get_hctl(struct sysfs_cxt *cxt, int *h,
 			       int *c, int *t, int *l);
 extern char *sysfs_scsi_host_strdup_attribute(struct sysfs_cxt *cxt,
diff -up util-linux-2.23.2/libblkid/src/blkidP.h.kzak util-linux-2.23.2/libblkid/src/blkidP.h
--- util-linux-2.23.2/libblkid/src/blkidP.h.kzak	2015-07-03 10:29:08.582688645 +0200
+++ util-linux-2.23.2/libblkid/src/blkidP.h	2015-07-03 10:30:50.378965526 +0200
@@ -221,6 +221,7 @@ struct blkid_struct_probe
 #define BLKID_FL_PRIVATE_FD	(1 << 1)	/* see blkid_new_probe_from_filename() */
 #define BLKID_FL_TINY_DEV	(1 << 2)	/* <= 1.47MiB (floppy or so) */
 #define BLKID_FL_CDROM_DEV	(1 << 3)	/* is a CD/DVD drive */
+#define BLKID_FL_NOSCAN_DEV	(1 << 4)        /* do not scan this device */
 
 /* private per-probing flags */
 #define BLKID_PROBE_FL_IGNORE_PT (1 << 1)	/* ignore partition table */
diff -up util-linux-2.23.2/libblkid/src/partitions/partitions.c.kzak util-linux-2.23.2/libblkid/src/partitions/partitions.c
--- util-linux-2.23.2/libblkid/src/partitions/partitions.c.kzak	2015-07-03 10:29:08.582688645 +0200
+++ util-linux-2.23.2/libblkid/src/partitions/partitions.c	2015-07-03 10:30:50.378965526 +0200
@@ -537,6 +537,8 @@ static int idinfo_probe(blkid_probe pr,
 
 	if (pr->size <= 0 || (id->minsz && id->minsz > pr->size))
 		goto nothing;	/* the device is too small */
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		goto nothing;
 
 	rc = blkid_probe_get_idmag(pr, id, &off, &mag);
 	if (rc != BLKID_PROBE_OK)
@@ -576,8 +578,12 @@ static int partitions_probe(blkid_probe
 
 	if (!pr || chn->idx < -1)
 		return -EINVAL;
+
 	blkid_probe_chain_reset_vals(pr, chn);
 
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		return BLKID_PROBE_NONE;
+
 	if (chn->binary)
 		partitions_init_data(chn);
 
@@ -653,6 +659,8 @@ int blkid_partitions_do_subprobe(blkid_p
 
 	if (!pr || !parent || !parent->size)
 		return -EINVAL;
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		return BLKID_PROBE_NONE;
 
 	/* range defined by parent */
 	sz = ((blkid_loff_t) parent->size) << 9;
@@ -707,6 +715,9 @@ static int blkid_partitions_probe_partit
 	blkid_partition par;
 	dev_t devno;
 
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		goto nothing;
+
 	devno = blkid_probe_get_devno(pr);
 	if (!devno)
 		goto nothing;
@@ -779,7 +790,7 @@ nothing:
 int blkid_probe_is_covered_by_pt(blkid_probe pr,
 				 blkid_loff_t offset, blkid_loff_t size)
 {
-	blkid_probe prc;
+	blkid_probe prc = NULL;
 	blkid_partlist ls = NULL;
 	blkid_loff_t start, end;
 	int nparts, i, rc = 0;
@@ -788,6 +799,9 @@ int blkid_probe_is_covered_by_pt(blkid_p
 		"=> checking if off=%jd size=%jd covered by PT",
 		offset, size));
 
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		goto done;
+
 	prc = blkid_clone_probe(pr);
 	if (!prc)
 		goto done;
diff -up util-linux-2.23.2/libblkid/src/probe.c.kzak util-linux-2.23.2/libblkid/src/probe.c
--- util-linux-2.23.2/libblkid/src/probe.c.kzak	2015-07-03 10:29:08.583688638 +0200
+++ util-linux-2.23.2/libblkid/src/probe.c	2015-07-03 10:30:50.378965526 +0200
@@ -110,6 +110,7 @@
 
 #include "blkidP.h"
 #include "all-io.h"
+#include "sysfs.h"
 
 /* chains */
 extern const struct blkid_chaindrv superblocks_drv;
@@ -714,8 +715,13 @@ int blkid_probe_set_device(blkid_probe p
 	if (pr->size <= 1440 * 1024 && !S_ISCHR(sb.st_mode))
 		pr->flags |= BLKID_FL_TINY_DEV;
 
+	if (S_ISBLK(sb.st_mode) && sysfs_devno_is_lvm_private(sb.st_rdev)) {
+		DBG(LOWPROBE, blkid_debug("ignore private LVM device"));
+		pr->flags |= BLKID_FL_NOSCAN_DEV;
+        }
+
 #ifdef CDROM_GET_CAPABILITY
-	if (S_ISBLK(sb.st_mode) &&
+	else if (S_ISBLK(sb.st_mode) &&
 	    !blkid_probe_is_tiny(pr) &&
 	    blkid_probe_is_wholedisk(pr) &&
 	    ioctl(fd, CDROM_GET_CAPABILITY, NULL) >= 0)
@@ -892,6 +898,9 @@ int blkid_do_probe(blkid_probe pr)
 	if (!pr)
 		return -1;
 
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		return 1;
+
 	do {
 		struct blkid_chain *chn = pr->cur_chain;
 
@@ -1143,6 +1152,8 @@ int blkid_do_safeprobe(blkid_probe pr)
 
 	if (!pr)
 		return -1;
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		return 1;
 
 	blkid_probe_start(pr);
 
@@ -1197,6 +1208,8 @@ int blkid_do_fullprobe(blkid_probe pr)
 
 	if (!pr)
 		return -1;
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		return 1;
 
 	blkid_probe_start(pr);
 
diff -up util-linux-2.23.2/libblkid/src/superblocks/superblocks.c.kzak util-linux-2.23.2/libblkid/src/superblocks/superblocks.c
--- util-linux-2.23.2/libblkid/src/superblocks/superblocks.c.kzak	2015-07-03 10:29:08.586688617 +0200
+++ util-linux-2.23.2/libblkid/src/superblocks/superblocks.c	2015-07-03 10:30:50.378965526 +0200
@@ -335,6 +335,9 @@ static int superblocks_probe(blkid_probe
 
 	if (!pr || chn->idx < -1)
 		return -EINVAL;
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		goto nothing;
+
 	blkid_probe_chain_reset_vals(pr, chn);
 
 	DBG(LOWPROBE, blkid_debug("--> starting probing loop [SUBLKS idx=%d]",
@@ -450,6 +453,9 @@ static int superblocks_safeprobe(blkid_p
 	int intol = 0;
 	int rc;
 
+	if (pr->flags & BLKID_FL_NOSCAN_DEV)
+		return 1;				/* nothing */
+
 	while ((rc = superblocks_probe(pr, chn)) == 0) {
 
 		if (blkid_probe_is_tiny(pr) && !count)
diff -up util-linux-2.23.2/libblkid/src/verify.c.kzak util-linux-2.23.2/libblkid/src/verify.c
--- util-linux-2.23.2/libblkid/src/verify.c.kzak	2013-06-13 09:46:10.429650699 +0200
+++ util-linux-2.23.2/libblkid/src/verify.c	2015-07-03 10:30:50.378965526 +0200
@@ -112,6 +112,10 @@ blkid_dev blkid_verify(blkid_cache cache
 		   (unsigned long)diff));
 #endif
 
+	if (sysfs_devno_is_lvm_private(st.st_rdev)) {
+		blkid_free_dev(dev);
+		return NULL;
+	}
 	if (!cache->probe) {
 		cache->probe = blkid_new_probe();
 		if (!cache->probe) {
diff -up util-linux-2.23.2/lib/sysfs.c.kzak util-linux-2.23.2/lib/sysfs.c
--- util-linux-2.23.2/lib/sysfs.c.kzak	2013-06-13 09:46:10.410650536 +0200
+++ util-linux-2.23.2/lib/sysfs.c	2015-07-03 10:32:32.953236879 +0200
@@ -638,6 +638,35 @@ err:
     return -1;
 }
 
+/*
+ * Returns 1 if the device is private LVM device.
+ */
+int sysfs_devno_is_lvm_private(dev_t devno)
+{
+	struct sysfs_cxt cxt = UL_SYSFSCXT_EMPTY;
+	char *uuid = NULL;
+	int rc = 0;
+
+	if (sysfs_init(&cxt, devno, NULL) != 0)
+		return 0;
+
+	uuid = sysfs_strdup(&cxt, "dm/uuid");
+
+	/* Private LVM devices use "LVM-<uuid>-<name>" uuid format (important
+	 * is the "LVM" prefix and "-<name>" postfix).
+	 */
+	if (uuid && strncmp(uuid, "LVM-", 4) == 0) {
+		char *p = strrchr(uuid + 4, '-');
+
+		if (p && *(p + 1))
+			rc = 1;
+	}
+
+	sysfs_deinit(&cxt);
+	free(uuid);
+	return rc;
+}
+
 
 int sysfs_scsi_get_hctl(struct sysfs_cxt *cxt, int *h, int *c, int *t, int *l)
 {
